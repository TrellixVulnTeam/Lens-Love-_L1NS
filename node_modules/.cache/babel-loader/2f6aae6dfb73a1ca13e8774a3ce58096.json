{"ast":null,"code":"import { firestore } from './../../firebase/utils';\nexport const handleAddProduct = product => {\n  return new Promise((resolve, reject) => {\n    firestore.collection('products').doc().set(product).then(() => {\n      resolve();\n    }).catch(err => {\n      reject(err);\n    });\n  });\n};\nexport const handleFetchProducts = _ref => {\n  let {\n    filterType,\n    startAfterDoc,\n    persistProducts = []\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    const pageSize = 6;\n    let ref = firestore.collection('products').orderBy('createdDate').limit(pageSize);\n    if (filterType) ref = ref.where('productCategory', '==', filterType);\n    if (startAfterDoc) ref = ref.startAfter(startAfterDoc);\n    ref.get().then(snapshot => {\n      const totalCount = snapshot.size;\n      const data = [...persistProducts, ...snapshot.docs.map(doc => {\n        return { ...doc.data(),\n          documentID: doc.id\n        };\n      })];\n      resolve({\n        data,\n        queryDoc: snapshot.docs[totalCount - 1],\n        isLastPage: totalCount < 1\n      });\n    }).catch(err => {\n      reject(err);\n    });\n  });\n};\nexport const handleEditProduct = documentID => {\n  return new Promise((resolve, reject) => {\n    firestore.collection('products').doc(productID).get().then(snapshot => {\n      if (snapshot.exists) {\n        resolve({ ...snapshot.data(),\n          documentID: productID\n        });\n      }\n    }).catch(err => {\n      reject(err);\n    });\n  });\n};\nexport const handleDeleteProduct = documentID => {\n  return new Promise((resolve, reject) => {\n    firestore.collection('products').doc(documentID).delete().then(() => {\n      console.log(documentID, 2);\n      resolve();\n    }).catch(err => {\n      reject(err);\n    });\n  });\n};\nexport const handleUpdateStock = documentID => {\n  return new Promise((resolve, reject) => {\n    firestore.collection('products').doc(documentID).update({}).then(() => {\n      resolve();\n    }).catch(err => {\n      reject(err);\n    });\n  });\n};\nexport const handleFetchProduct = productID => {\n  return new Promise((resolve, reject) => {\n    firestore.collection('products').doc(productID).get().then(snapshot => {\n      if (snapshot.exists) {\n        resolve({ ...snapshot.data(),\n          documentID: productID\n        });\n      }\n    }).catch(err => {\n      reject(err);\n    });\n  });\n};","map":{"version":3,"sources":["C:/Users/HP/OneDrive/Desktop/taskEcommerce/src/redux/Products/products.helpers.js"],"names":["firestore","handleAddProduct","product","Promise","resolve","reject","collection","doc","set","then","catch","err","handleFetchProducts","filterType","startAfterDoc","persistProducts","pageSize","ref","orderBy","limit","where","startAfter","get","snapshot","totalCount","size","data","docs","map","documentID","id","queryDoc","isLastPage","handleEditProduct","productID","exists","handleDeleteProduct","delete","console","log","handleUpdateStock","update","handleFetchProduct"],"mappings":"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","sourcesContent":["import { firestore } from './../../firebase/utils';\n\nexport const handleAddProduct = product => {\n  return new Promise((resolve, reject) => {\n    firestore\n      .collection('products')\n      .doc()\n      .set(product)\n      .then(() => {\n        resolve();\n      })\n      .catch(err => {\n        reject(err);\n      })\n  });\n}\n\nexport const handleFetchProducts = ({ filterType, startAfterDoc, persistProducts=[] }) => {\n  return new Promise((resolve, reject) => {\n    const pageSize = 6;\n\n    let ref = firestore.collection('products').orderBy('createdDate').limit(pageSize);\n\n    if (filterType) ref = ref.where('productCategory', '==', filterType);\n    if (startAfterDoc) ref = ref.startAfter(startAfterDoc);\n\n    ref\n      .get()\n      .then(snapshot => {\n        const totalCount = snapshot.size;\n\n        const data = [\n          ...persistProducts,\n          ...snapshot.docs.map(doc => {\n            return {\n              ...doc.data(),\n              documentID: doc.id\n            }\n          })\n        ];\n\n        resolve({\n          data,\n          queryDoc: snapshot.docs[totalCount - 1],\n          isLastPage: totalCount < 1\n        });\n      })\n      .catch(err => {\n        reject(err);\n      })\n  })\n}\n\nexport const handleEditProduct = documentID => {\n  return new Promise((resolve, reject) => {\n    firestore\n    .collection('products')\n    .doc(productID)\n    .get()\n    .then(snapshot => {\n\n      if (snapshot.exists) {\n        resolve({\n          ...snapshot.data(),\n          documentID: productID\n        });\n      }\n    })\n    .catch(err => {\n      reject(err);\n      })\n  });\n}\nexport const handleDeleteProduct = documentID => {\n  return new Promise((resolve, reject) => {\n    firestore\n      .collection('products')\n      .doc(documentID)\n      .delete()\n      .then(() => {\n        console.log(documentID, 2)\n        resolve();\n      })\n      .catch(err => {\n        reject(err);\n      })\n  });\n}\n\nexport const handleUpdateStock = (documentID) =>{\n  return new Promise((resolve,reject)=>{\n    firestore\n    .collection('products')\n    .doc(documentID)\n    .update({\n      \n    })\n    .then(()=>{\n      resolve();\n    })\n    .catch(err=>{\n      reject(err);\n    })\n  })\n}\n\nexport const handleFetchProduct = (productID) => {\n  return new Promise((resolve, reject) => {\n    firestore\n      .collection('products')\n      .doc(productID)\n      .get()\n      .then(snapshot => {\n\n        if (snapshot.exists) {\n          resolve({\n            ...snapshot.data(),\n            documentID: productID\n          });\n        }\n      })\n      .catch(err => {\n        reject(err);\n      })\n  })\n}"]},"metadata":{},"sourceType":"module"}